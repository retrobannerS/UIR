\chapter{Анализ проблематики взаимодействия нетехнических пользователей
  с базами данных и обзор перспективных способов решения данной проблемы}
\label{chapter1}

\begin{annotation}
      В данной аннотации представлен обзор проблематики взаимодействия нетехнических пользователей
      с базами данных. Проведен анализ существующих моделей представления данных и способов
      взаимодействия с СУБД, выявлен основной барьер для пользователей без технической подготовки.
      Рассмотрены и сравнены современные интерфейсы работы с базами данных,
      ориентированные на нетехнических специалистов, выделен наиболее перспективный подход~---
      естественно-языковые интерфейсы (NLIDB). Описана эволюция методов преобразования
      естественного языка в SQL-запросы, проведён анализ современных моделей и веб-сервисов,
      а также обоснована актуальность разработки собственного веб-сервиса на базе открытого
      фреймворка XiYan-SQL.
\end{annotation}




\section{Обзорный анализ традиционных способов взаимодействия разработчиков с базами данных и
  постановка задачи исследования}%
\begin{annotation}
      Для разработки эффективных методов помощи технически неподкованным пользователям необходимо,
      в первую очередь, систематизировать виды баз данных, с которыми они могут столкнуться, и
      проанализировать традиционные способы взаимодействия программистов с ними.
      В данном разделе рассматриваются методы структурирования данных, известные на данный момент,
      а также освещаются методы общения разработчиков с СУБД. На этой основе формулируется
      основной предмет дальнейшего исследования.
\end{annotation}

Информационные технологии уже стали частью жизни общества и продолжают своё развитие,
а объём данных постоянно увеличивается в геометрической прогрессии,
поэтому вопрос оптимальной систематизации и хранения данных особенно
актуален в современном мире~\cite{savoskinIssledovanieSposobovPrimeneniya2019}.

Информация и данные лежат основе информационных технологий.
В теории баз данных понятия \textit{информации} и \textit{данных} являются ключевыми.
Под \textit{информацией} понимаются любые сведения о каком-либо событии, процессе, объекте.
Под \textit{данными} понимается информация, представленная в определенном виде,
позволяющем автоматизировать ее сбор, хранение и дальнейшую обработку человеком или
информационным средством~\cite{burakovVvedenie2010}.

Приведём еще несколько основных понятий и определений из теории баз данных:
\begin{compactitem}
      \item \textit{База данных} (БД) --- это именованная совокупность данных,
      отражающая состояние объектов и их отношений в рассматриваемой предметной области.
      БД состоит из множества связанных файлов.
      \item \textit{Система управления базами данных} (СУБД) --- совокупность языковых и программных средств,
      предназначенных для создания, ведения и совместного использования БД многими пользователями.
\end{compactitem}




\subsection{Классификация баз данных по модели представления данных}

Исторически сложились различные подходы к структурированию данных, реализованных в СУБД, поэтому их можно
классифицировать по модели представления данных.

\paragraph{Устаревшие модели}. До появления современных информационных технологий и
развития компьютерной техники, методы хранения данных, использовавшиеся в библиотеках и архивах,
были взяты за основу для их упорядоченного хранения~\cite{koryaginModeliBazDannyh2020}.
Эти ранние модели, хотя и менее распространены сегодня, заложили основу для более сложных систем:
\begin{compactitem}
      \item \textbf{Иерархическая модель}. Данные в ней представлены в виде дерева.
      Она отлично подходит для описания предметной области,
      где объекты можно упорядочить по степени подчиненности друг другу.
      Данная модель БД быстро предоставляет пользователю запрашиваемую информацию,
      однако она не отличается гибкостью. Примеры использования: LDAP и Active Directory,
      база настройки Windows WMI и Реестр Windows, Google App Engine DataStore API.
      \item\textbf{Сетевая модель}. Является расширением иерархической базы данных.
      В отличие от иерархической, у потомка может быть более одного родителя,
      что позволяет описывать более широкий класс взаимоотношений между данными, например отношения «многие ко многим».
      Недостатком является сложность и неудобство работы, возникающих при увеличении размера БД. Примеры использования:
      графические системы формирования 3D-изображений, системы пространственной координации объектов.
\end{compactitem}

\paragraph{Реляционные базы данных (SQL)}. Данные в такой модели представляются в виде
таблиц. Столбец одной таблицы может быть связан со столбцом другой таблицы.
Так реализовано взаимоотношение между объектами~\cite{koryaginModeliBazDannyh2020,smallcombeSQLVsNoSQL,
      savoskinIssledovanieSposobovPrimeneniya2019, kleymenovNoSQLRelyacionnyeBazy2022}.
Из преимуществ данного класса баз данных можно выделить
строгую стандартизированность и основное взаимодействие с помощью специального языка SQL,
а также надежность, популярность и успешность в сообществе.
Из недостатков можно выделить отсутствие горизональной масштабируемости
и строгую структуризацию данных~\cite{koryaginModeliBazDannyh2020}.
Примеры реляционных СУБД (РСУБД): Oracle, MySQL, Microsoft SQL Server, PostgreSQL, SQLite, DB2, Sybase.

\paragraph{NoSQL базы данных}. Изначально термин «NoSQL» появился в конце 90-х годов 20-го века,
когда он расшифровывался «Без SQL», то есть взаимодействие с ними производилось без языка SQL.
Нынешняя интерпретация как «Not only SQL» сформировалось лишь в 2009 году, и  подразумевает под собой,
что поддержка SQL является лишь одним из  компонентов системы~\cite{savoskinIssledovanieSposobovPrimeneniya2019,
      smallcombeSQLVsNoSQL}. Они предлагают более гибкий подход, идеальный для работы с неструктурированными или
динамическими данными, без жесткой предопределенной схемы.
Из преимуществ можно отметить поддержку горизонтального масштабирования и поддержку хранения различных типов данных,
из недостатков --- большее потребление дискового пространства, сниженную надежность по сравнению с SQL-решениями, а также
отсустствие жесткой стандартизации, что означает вариацию способа взаимодействия при переходе от базы к
базе~\cite{savoskinIssledovanieSposobovPrimeneniya2019, koryaginModeliBazDannyh2020,smallcombeSQLVsNoSQL,
      kleymenovNoSQLRelyacionnyeBazy2022, savoskinIssledovanieSposobovPrimeneniya2019}.
Ниже приведены основные типы NoSQL СУБД и способы взаимодействия с ними.
\begin{compactitem}
      \item \textbf{Графовые СУБД}. Предназначены для обработки данных, которые легче представить в виде графа,
      чем в виде таблиц. Используются в основном при создании транспортных маршрутов,
      семантических сетей и социальных сетей. Примеры СУБД: Neo4j (самая распространённая),
      OrientDB, InfiniteGraph. Запросы к Neo4j в основном выполняются на декларативном языке
      Cypher~\cite{maranAlternativeApproachesData2020, savoskinIssledovanieSposobovPrimeneniya2019}.
      \item \textbf{Документо-ориентированные СУБД}. Представляют информацию в форме иерархических структур данных.
      Единицей представления данных является документ, который имеет набор индивидуальных атрибутов. Используются в
      издательском деле, документальном поиске, системе управления содержимым. Примеры СУБД:
      MongoDB (самая распространённая), CouchDB, ElasticSearch.
      Для взаимодействия с MongoDB используется JSON-подобный язык запросов~\cite{maranAlternativeApproachesData2020,
            savoskinIssledovanieSposobovPrimeneniya2019}.
      \item \textbf{Хранилища пар «ключ-значние»}. Представляют собой хэш-таблицу,
      содержащую значения и соответствующие им ключи. Примеры использования: хранение изображений,
      использование в качестве кэша объектов. Примеры СУБД: Redis (самая распространенная), Memcached, Riak, MemcacheDB.
      Запросы выполняются через вызовы API на языках программирования. Reddis поддерживает скрипты на языке
      Lua~\cite{ivanovObzorSovremennyhNoSQL2019,savoskinIssledovanieSposobovPrimeneniya2019}.
      \item \textbf{Колоночные СУБД}. В отличие от реляционных БД, хранят данные не строками, а в колонках. Это
      позволяет применять эффективное сжатие, так как каждая колонка содержит только один тип данных.
      Примеры использования: веб-индексирование, задачи с большими данными, но с пониженными требованиями
      к согласованности. Примеры СУБД: Cassandra(самая распространенная), HBase, Vertica.
      Запросы к Cassandra выполняются через декларативный язык CQL (Cassandra Query Language) и вызовы
      API~\cite{ivanovObzorSovremennyhNoSQL2019,savoskinIssledovanieSposobovPrimeneniya2019}.
\end{compactitem}

\paragraph{Мультимодельные базы данных}. Также существуют мультимодельные базы данных,
которые включают две или более из представленных выше категорий.

Приведённая классификация освещает большинство СУБД, использующихся в современных IT-проектах.




\subsection{Способы взаимодействия технических специалистов с базами данных}

Основываясь на представленных моделях данных, можно выделить несколько основных парадигм взаимодействия
разработчика или программного обеспечения с СУБД для выполнения запросов и манипуляции данными.
Эта классификация важна для понимания, какие навыки требуются от пользователя для работы с той или иной системой.

\paragraph{С помощью декларативных языков запросов}. Это наиболее распространённый способ взаимодействия,
при котором пользователь описывает, какие данные он хочет получить, но не указывает,
как именно системе следует их извлекать. Система сама оптимизирует и выполняет запрос.
К примерам таких языков можно отнести SQL для запросов к реляционным БД, Cypher для взаимодействия с Neo4j, CQL для Cassandra.

\paragraph{С помощью документо-подобных языков запросов}. Взаимодействие происходит с помощью объектов,
структура которых напоминает структуру данных в самой базе.
Ярким примером является язык запросов в MongoDB, где для поиска, фильтрации и модификации данных
используются JSON-подобные документы. Хотя этот подход мощен и гибок, он менее стандартизирован,
чем SQL, и тесно связан со структурой хранимых документов, поэтому данный способ может показаться достаточно
сложным даже для подкованного пользователя, решившего применить документо-ориентированную СУБД в своём
проекте~\cite{yakushinSravnitelnyyAnalizRelyacionnoy2018}.

\paragraph{Программные интерфейсы (API)}. В этой модели взаимодействие с базой данных происходит
не через специальный язык запросов, а через вызовы функций (API) из кода приложения,
написанного на языках программирования вроде Python, Java, C\# и других.
Этот подход характерен как основной для многих NoSQL-хранилищ.
Он достаточно прост и предоставляет разработчикам полный контроль, но требует навыков
программирования~\cite{yakushinSravnitelnyyAnalizRelyacionnoy2018,
      ivanovObzorSovremennyhNoSQL2019}.

\paragraph{Специализированные и графические интерфейсы}.
Некоторые системы, такие как Active Directory или Реестр Windows, используют узкоспециализированные
утилиты командной строки или графические интерфейсы для взаимодействия.
Также для многих популярных СУБД существуют административные панели
(например, pgAdmin для PostgreSQL), которые предоставляют графический интерфейс для
выполнения запросов и управления базой данных. Часто они являются надстройкой над основными способами взаимодействия,
и поэтому пользователи должны иметь опыт работы с основным языком запросов к используемой базе данных.




\subsection{Выбор объекта исследования}

Проведенный анализ показывает, что мир баз данных разнообразен как по моделям хранения данных,
так и по способам взаимодействия с ними. Для нетехнического специалиста, желающего извлечь информацию,
это многообразие создает значительные трудности.
Декларативные языки запросов требуют опыта работы с ними.
Документо-подобные подходы и API требуют специальных знаний в области программирования
и понимания конкретной СУБД. Графические интерфейсы служат скорее удобной средой для
технических специалистов, чем полноценным решением для пользователей, не владеющих
языком запросов.

На этом фоне исследовательский интерес представляют
пользовательские интерфейсы, адаптированные для людей без технических навыков. Они позволяют
не только программистам, но и каждому пользователю общаться с системой, не проходя специализированную
подготовку в части формальных языков.

Таким образом, в качестве центральной задачи данного исследования выбирается обзор существующих
пользовательских интерфейсов, которые предлагают альтернативные способы взаимодействия
с базами данных.




\section{Сравнительный анализ интерфейсов баз данных для нетехнических пользователей}
\begin{annotation}
      В данном разделе проводится сравнение подходов к разработке интерфейсов баз данных,
      ориентированных на нетехнических пользователей: запросов по примеру (QBE), визуальных систем запросов (VQS) и
      естественно-языковых интерфейсов (NLIDB).
      Для каждого подхода выделяются ключевые особенности,
      преимущества и недостатки с точки зрения доступности, гибкости и требований к пользователю.
      На основе анализа выделяется наиболее перспективный вид интерфейса для дальнейших исследований и разработки.
\end{annotation}




\subsection{Запрос по примеру (Query By Example)}

Query By Example (QBE) --- визуальный язык запросов, который был разработан параллельно с SQL с целью
предоставить высокоуровневый и унифицированный интерфейс для взаимодействия с реляционными
базами данных. Он был изначально ориентирован на пользователей,
практически не имевших опыта в разработке, и предполагал ввод данных в пустые
схематические таблицы на экране путём заполнения
форм~\cite{maranAlternativeApproachesData2020, zloofQuerybyexampleDataBase1977}.

Основным преимуществом QBE является его интуитивность и низкий порог вхождения.
Пользователю не требуется изучать сложный синтаксис,
так как запросы формируются путем заполнения таблиц-шаблонов,
предоставляя пример желаемого результата~\cite{catarciVisualQuerySystems1997,zloofQuerybyexampleDataBase1977}.
Это позволяет постепенно переходить от простых запросов к более сложным,
а психологические исследования показали, что непрограммисты могут освоить язык менее
чем за три часа~\cite{zloofQuerybyexampleDataBase1977}.

Однако у данного подхода есть и существенные недостатки.
Во-первых, как уже отмечалось, QBE работает только с реляционными базами данных.
Во-вторых, QBE не позволяет формировать сложные запросы, например, с подзапросами или объединениями,
что делает его абсолютно бесполезным в профессиональной деятельности.
Некоторые источники отмечают, что обучение QBE вместо SQL является нецелесообразным,
поскольку этот язык не используется в профессиональном программировании и
не способствует развитию навыков работы с
базами данных~\cite{pirogovNekotoryeOsobennostiPrepodavaniya2018}.
Тем не менее, QBE получил широкое признание как концепция и лёг в основу таких
популярных инструментов, как Microsoft Access~\cite{maranAlternativeApproachesData2020}.




\subsection{Визуальные системы запросов (Visual Query Systems)}

Для решения проблемы доступа
к данным для нетехнических пользователей были разработаны визуальные
системы запросов (Visual Query Systems, VQS), которые предоставляют интуитивно понятные интерфейсы,
не требующие знания формальных языков~\cite{catarciVisualQuerySystems1996,
      catarciVisualQuerySystems1997, baskaranSyntaticSemanticVisual2013}.

Ключевой особенностью визуальных конструкторов является замена текстового ввода на прямое
манипулирование визуальными элементами~\cite{catarciVisualQuerySystems1996}. Пользователи
взаимодействуют с графическими представлениями данных~--- формами, диаграммами или иконками~---,
а система автоматически преобразует эти действия в формальный запрос~\cite{soumisVisualQueryBuilder2025,
      stigebornQueryBuilderDatabase2015}.

Существует несколько подходов к визуализации:
\begin{compactitem}
      \item \textbf{На основе форм (Form-based):} Пользователь заполняет таблицы-шаблоны,
      предоставляя пример желаемого результата. Классическим примером является
      Query-By-Example (QBE)~\cite{catarciVisualQuerySystems1997}.
      \item \textbf{На основе диаграмм (Diagram-based):} Запросы строятся путем взаимодействия со схемами,
      такими как диаграммы <<сущность-связь>> (ER). Например, система VIREX генерирует
      интерактивную ER-диаграмму, на которой пользователи могут выбирать таблицы и
      атрибуты с помощью щелчков мыши~\cite{loVIREXVRXQueryInteractive2010}.
      Аналогично, Visual Query Builder в DBeaver позволяет перетаскивать
      таблицы и выбирать столбцы, автоматически генерируя SQL-код.
      Современные реализации, такие как DBpedia Visualizer,
      позволяют строить визуальный граф для создания SPARQL-запросов~\cite{soumisVisualQueryBuilder2025}.
      \item \textbf{На основе иконок (Icon-based):} Объекты и операции представляются в виде иконок,
      что особенно полезно для пользователей, не знакомых даже с
      концепцией схемы базы данных~\cite{catarciVisualQuerySystems1997}.
\end{compactitem}

Эти системы ориентированы на так называемых <<случайных пользователей>> (casual users),
которые взаимодействуют с базами данных нерегулярно и
не имеют времени на обучение~\cite{catarciVisualQuerySystems1997, catarciVisualQuerySystems1996}.
Несмотря на свои преимущества, визуальные интерфейсы могут иметь ограничения при работе
с большими и сложными наборами данных, и от пользователя все еще может потребоваться
некоторое понимание структуры схемы~\cite{baskaranSyntaticSemanticVisual2013}.




\subsection{Естественно-языковые интерфейсы (Natural language interfaces)}

В отличие от визуальных конструкторов, интерфейсы на естественном языке
(Natural language interfaces to the databases, NLIDB) стремятся полностью устранить
барьер между пользователем и базой данных, позволяя формулировать запросы на обычном разговорном языке,
например, русском или английском~\cite{anisyahNaturalLanguageInterface2019,
      bolyabkinIntellektualnayaSistemaDlya2021, borodinZadacheSostavleniyaZaprosov2016}.
Основная цель NLIDB --- предоставить нетехническим пользователям
возможность напрямую взаимодействовать с базами данных,
что делает их незаменимым инструментом для широкого круга
специалистов~\cite{desaiNaturalLanguageInterface2023, kumarEnhancingRelationalDatabase2024}.

Важно понимать, что в основе работы таких интерфейсов лежат специальные алгоритмы или модели,
обеспечивающие функциональность. Задача к конструированию таких моделей в машинном обучении
называется <<Text-to-SQL>>. Также возможны формулировки <<NL-to-SQL>>, <<Text2SQL>>, <<NL2SQL>>.

Исследования в этой области ведутся с 1970-х годов, начиная с таких систем,
как LUNAR~\cite{kimNaturalLanguageSQL2020,liuNLI4DBSystematicReview2025, zhuLargeLanguageModel2024}.
Темп публикации научных
статей в этой области на сегодняшний день довольно интенсивный, что свидетельствует о
высоком интересе исследовательского сообщества
к проблеме построения эффективных моделей, лежащих в основе NLIDB, и постоянном совершенствовании методов
преобразования естественного языка в формальные запросы.
Основные подходы к реализации функционирования NLIDB можно классифицировать следующим образом:
\begin{compactitem}
      \item \textbf{Подходы на основе правил и синтаксиса.} Используют лингвистический анализ,
      включая синтаксические парсеры и онтологии, для преобразования запроса в SQL.
      Эти методы точны, но часто ограничены конкретной предметной
      областью~\cite{anisyahNaturalLanguageInterface2019, poetraNaturalLanguageInterface2019,
            hamazNovelMethodProviding2017, pazosr.ComparativeStudyCustomization2016,
            baskaranSyntaticSemanticVisual2013}.
      \item \textbf{Подходы на основе моделей глубокое обучения.} Они уже рассматривают задачу
      из области машинного обучения как перевод с
      естественного языка на SQL (<<Text-to-SQL>>). Здесь применяются нейросетевые архитектуры,
      такие как LSTM и Transformer, обучаемые на датасетах
      вида множества пар <<запрос-SQL>>~\cite{bradDatasetNeuralNatural2017,
            visperasModernTexttoSQLSemantic2023}. Они более гибки, чем системы на основе правил,
      однако часто менее точны.
      \item \textbf{Большие языковые модели (LLM).} Этот этап стал прорывным в развитии NLIDB.
      Модели вроде GPT способны генерировать SQL-запросы с высокой точностью, не требуя
      при этом детального описания контекста. Модели могут вовсе не требовать знать о конкретной
      задаче (Zero-Shot), могут потребовать знать небольшое количество примеров (Few-shot), а также
      могут использовать техники, основанные на рассуждениях, например
      Chain-of-Thought~\cite{liCodeSBuildingOpensource2024,
            zhuLargeLanguageModel2024}.
      \item \textbf{Системы, использующие логи запросов.} Такие подходы, как Templar,
      анализируют логи ранее выполненных SQL-запросов для уточнения сопоставления
      ключевых слов и вывода правильных объединений таблиц, что повышает точность
      системы~\cite{baikBridgingSemanticGap2019,kimNaturalLanguageSQL2020}.
\end{compactitem}

Уникальность NLIDB по сравнению с VQB заключается в полном абстрагировании пользователя
от структуры базы данных. Если VQB требует от пользователя понимания, какие таблицы и поля
существуют, и как их визуально соединить для получения результата, то NLIDB позволяет
формулировать запрос так, как если бы он был адресован человеку. Главное преимущество
NLIDB~--- это его интуитивность и доступность для самой широкой
аудитории~\cite{vermaPunjabiLanguageInterface2013}. Однако основной недостаток кроется в
присущей естественному языку неоднозначности (полисемия, синонимия,
идиомы), что создает
значительные трудности для точной интерпретации запросов и требует сложных алгоритмов для
их разрешения~\cite{kimNaturalLanguageSQL2020, sidorovEstestvennyeIskusstvennyeYazyki2024}.


\subsection{Результаты сравнения и выявление наиболее перспективного метода}
Проанализировав три основных подхода к взаимодействию с базами данных для
нетехнических пользователей~--- Query By Example (QBE),
визуальные конструкторы запросов (VQB) и
естественно-языковые интерфейсы (NLIDB)~--- можно выявить их ключевые различия,
преимущества и недостатки. Результаты сравнения представлены в виде таблицы (см.~табл.~\ref{table:interfaces}).

\begin{table}[ht]
      \caption{Сравнительная таблица интерфейсов, адаптированных для нетехнических пользователей}\label{table:interfaces}
      \begin{tabularx}{\linewidth}{|>{\bfseries}c|X|X|X|X|}
            \hline
            \textnumero & \centering\textbf{Критерий сравнения}            & \textbf{QBE}                                                                          & \textbf{VQS}                                                                                                & \textbf{NLIDB}                                                                                               \\
            \hline
            1           & Уровень требований к нетехническому пользователю & \textbf{Средний.} Понимание структуры таблиц и базовых концепций запросов             & \textbf{Средний.} Понимание схемы БД                                                                        & \textbf{Низкий.} Имитирует естественное общение с компьютером                                                \\
            \hline
            2           & Уровень абстракции                               & \textbf{Низкий.} Пользователь напрямую работает с представлением таблиц               & \textbf{Средний.} Пользователь работает с диаграммами, но нужно помнить о связях таблиц в базе данных       & \textbf{Высокий.} Пользователь работает только с полем ввода текста                                          \\
            \hline
            3           & Гибкость запросов                                & \textbf{Низкая.} Подзапросы и объединения формировать затруднительно                  & \textbf{Средняя.} Позволяет создавать сложные запросы, но в рамках предложенного визуального инструментария & \textbf{Потенциально высокая.} Теоретически ограничена только способностью системы понять естественный язык. \\
            \hline
            4           & Основное преимущество                            & Простота и наглядность для простых запросов                                           & Наглядность связей между данными, сниженная вероятность синтаксических ошибок                               & Максимальная доступность и интуитивность. Низкий порог входа                                                 \\
            \hline
            5           & Основной недостаток                              & Слишком ограниченная функциональность и непригодность в профессиональной деятельности & Требует от пользователя предварительного изучения и понимания схемы конкретной базы данных                  & Требует аккуратной формулировки из-за неоднозначности естественного языка                                    \\
            \hline
      \end{tabularx}
\end{table}

Проведенный сравнительный анализ показывает, что каждый из рассмотренных типов интерфейсов предоставляет
удобства при взаимодействии человека с базой данных.
В этом контексте естественно-языковые интерфейсы (NLIDB) нацелены на устранение самого главного барьера~--- необходимости понимать,
как организованы данные. NLIDB позволяют пользователям формулировать свои потребности наиболее
естественным для человека способом, фокусируясь на содержании вопроса, а не на его технической форме.

Учитывая вышесказанное, дальнейшая работа будет сконцентрирована на исследовании и разработке систем,
основанных на естественно-языковом интерфейсе, как наиболее передовом и многообещающем подходе
к взаимодействию с базами данных.




\section{Обзорный анализ систем, решающих задачу Text-to-SQL}
\begin{annotation}
      В данном разделе проводится обзор истории и современного состояния систем,
      решающих задачу преобразования естественного языка в SQL-запросы (Text-to-SQL),
      лежащих в основе NLIDB. Рассматриваются ключевые этапы развития моделей:
      от ранних систем на правилах и синтаксическом анализе до современных решений на основе
      больших языковых моделей (LLM). Анализируются основные методологии построения современных систем,
      используемые датасеты и метрики оценки качества. На основании сравнительного анализа
      обосновывается выбор технологического ядра для реализации собственного NLIDB.
\end{annotation}

NLIDB под своей оболочкой скрывают сложные модели и алгоритмы, основная задача которых~--- преобразование
неструктурированного человеческого языка в формальные и исполняемые SQL-запросы. Таким образом, задача
создания эффективного NLIDB сводится к задаче разработки и выбора наиболее подходящей модели трансляции Text-to-SQL,
способной точно интерпретировать намерения пользователя и корректно взаимодействовать со схемой конкретной базы данных.

\subsection{Краткая история развития моделей Text-to-SQL}

Эволюция моделей для задачи Text-to-SQL отражает общие тенденции в области обработки естественного языка и
машинного обучения. Можно выделить три ключевых этапа, каждый из которых знаменовал собой качественный
скачок в развитии технологии. Эволюцию подходов также можно представить в виде иллюстрации
(см.~рис.~\ref{fig:text-to-sql-method-evolution}).

\begin{figure}[!htb]
      \centering
      \includegraphics[width=\textwidth]{literature-review/text-to-sql-method-evolution.png}
      \caption{Краткая история развития моделей Text-to-SQL}
      \label{fig:text-to-sql-method-evolution}
\end{figure}

\paragraph{Ранние системы и подходы, основанные на правилах (1970-е – 2000-е)}. Первые NLIDB,
появившиеся еще в 1970-х годах, такие как LUNAR и более поздние системы,
основанные на синтаксическом разборе и онтологиях, полностью полагались на вручную созданные грамматики,
словари и наборы правил. Эти системы были <<зажатыми>>, имели ограниченный словарный запас и
требовали значительных усилий для адаптации к каждой новой предметной области.
Их главным недостатком была низкая гибкость и неспособность справляться с лингвистической вариативностью и
неоднозначностью естественного языка~\cite{karimiNonEnglishNaturalLanguage2022,
      pazosr.ComparativeStudyCustomization2016, kimNaturalLanguageSQL2020,
      bradDatasetNeuralNatural2017, mohammadjafariNaturalLanguageSQL2025}.

\paragraph{Появление машинного обучения и нейронных сетей (2010-е)}. Первый прорыв произошел с
развитием глубокого обучения. Исследователи начали рассматривать задачу Text-to-SQL как задачу
машинного перевода. Появились модели на основе рекуррентных нейронных сетей (RNN), в частности,
архитектуры Sequence-to-Sequence (Seq2Seq) с механизмом внимания (attention),
которые обучались на размеченных данных~\cite{bradDatasetNeuralNatural2017, visperasModernTexttoSQLSemantic2023}.
Катализатором для бурного развития этого направления стало появление крупных аннотированных
наборов данных, таких как WikiSQL и, в особенности, Spider.
Это позволило создавать и объективно сравнивать более сложные и точные нейросетевые модели,
такие как TypeSQL и SyntaxSQLNet, которые учитывали структуру схемы базы данных и
показывали значительно лучшие результаты по сравнению с системами
на правилах~\cite{kimNaturalLanguageSQL2020, visperasModernTexttoSQLSemantic2023}.
Однако по-прежнему оставались проблемы, такие как обработка вложенных запросов,
обобщение на конкретную базу данных и сопоставление неоднозначного естественного языка со структурированным
SQL~\cite{mohammadjafariNaturalLanguageSQL2025}.

\paragraph{Эпоха больших языковых моделей (LLM) (2020-е -- настоящее время)}. Последние несколько лет
ознаменовались доминированием больших языковых моделей (LLM), таких как модели GPT-4,
PaLM и LLaMA, что привело к очередной смене парадигмы. LLM лучше справляются в задачах, требующих понимания
и генерации человекоподобного текста, часто без дополнительной настройки. Они лучше улавливают
сложные взаимосвязи между естественным языком и схемами базы данных~\cite{zhuLargeLanguageModel2024,
      mohammadjafariNaturalLanguageSQL2025}. Однако, несмотря на свой потенциал, эти подходы обычно сталкиваются с несколькими проблемами:
галлюцинации моделей, неконтролируемый результат, высокое требование к вычислительным ресурсам.

С появлением LLM, разработка новых решений для задачи Text-to-SQL показала
заметную тенденцию к росту с сентября 2023 по октябрь 2024 года,
что свидетельствует о значительном интересе со стороны сообщества.
Количество публикаций достигло пика с июля по октябрь 2024 года,
составив примерно 39\% от общего их числа на тему
LLM-основанных методов решения Text-to-SQL.
Ожидается, что текущие достижения в этой области приведут к последующим инновациям
в методах преобразования текста в SQL. Эти достижения позиционируют LLM как
основу современных систем преобразования естественного языка в SQL,
устраняя разрыв между разговорными и формальными языками с растущей точностью и
эффективностью~\cite{huangExploringLandscapeTexttoSQL2025}.

\subsection{Текущее положение в исследованиях подходов к решению задачи Text-to-SQL
      с помощью моделей, основанных на LLM}

Как упоминается в источнике~\cite{huangExploringLandscapeTexttoSQL2025},
современные научные статьи в области Text-to-SQL можно классифицировать
следующим образом:
\begin{compactitem}
      \item Методологии
      \begin{compactitem}
            \item Предобработка (Pre-Processing)
            \item Обучение в контексте (In-context learning)
            \item Тонкая настройка (Fine-Tuning)
            \item Постобработка (Post-Processing)
      \end{compactitem}
      \item Наборы данных (Datasets)
      \item Метрики применения (Evaluation Metrics)
\end{compactitem}

\noindent Рассмотрим каждый вопрос, рассматриваемый в академической литературе по-отдельности.

\subsubsection{Методологии}

Как уже было отмечено, современные подходы к решению задачи Text-to-SQL в основном опираются
на большие языковые модели. Однако сами по себе LLM не являются готовым решением и
требуют применения целого ряда инженерных практик и методологий для достижения
высокой точности и эффективности. Исследователи~\cite{huangExploringLandscapeTexttoSQL2025}
выделяют четыре основных парадигмы, в рамках которых ведутся разработки и улучшения
LLM-основанных систем: предварительная обработка (Pre-Processing),
обучение в контексте (In-context learning), тонкая настройка (Fine-Tuning) и
постобработка (Post-Processing), что охватывает весь жизненный цикл обработки языка.
Это можно продемонстрировать с иллюстрации (см.~рис.~\ref{fig:llm-query-pipeline}).

\begin{figure}[!ht]
      \centering
      \includegraphics[width=\textwidth]{literature-review/llm-query-pipeline.png}
      \caption{Блок-схема типового конвейера обработки запроса в современной LLM-системе.}
      \label{fig:llm-query-pipeline}
\end{figure}


\subsubsection{Предварительная обработка (Pre-Processing)}

Этот этап является ключевым
для подготовки и структурирования входных данных, что напрямую влияет на точность
генерируемого SQL-запроса. Основная задача здесь --- максимально снизить неоднозначность
и предоставить модели всю необходимую для работы информацию.
Одним из центральных методов является \textit{связывание со схемой} (Schema Linking), в
ходе которого система сопоставляет слова и фразы из естественного языка с конкретными таблицами,
столбцами и их отношениями в базе данных~\cite{huangExploringLandscapeTexttoSQL2025,
      mohammadjafariNaturalLanguageSQL2025}. Другой важный метод --- \textit{извлечение значений ячеек}
(Cell Value Acquisition), который позволяет обогатить контекст, добавив в него
релевантные примеры значений из базы данных, что особенно полезно, когда в запросе
пользователя отсутствуют детали, необходимые для точной генерации
SQL~\cite{huangExploringLandscapeTexttoSQL2025}. Наконец, для борьбы с присущей
естественному языку двусмысленностью применяется \textit{переписывание вопроса}
(Question Rewriting), где модель сначала переформулирует исходный запрос в более
четкий и однозначный, прежде чем приступать к генерации кода.

\subsubsection{Обучение в контексте (In-Context Learning, ICL)}

Данная парадигма
сосредоточена на инженерии промптов (prompt engineering) --- искусстве составления
такого запроса к модели, который бы наиболее эффективно направлял ее на решение конкретной
задачи без необходимости изменять веса самой модели. Основные подходы
здесь --- это \textit{Zero-shot} (без примеров) и \textit{Few-shot}
(с малым количеством примерам)~\cite{zhuLargeLanguageModel2024}. В последнем случае ключевую
роль играет стратегия отбора примеров.
Для решения нетривиальных задач применяется \textit{усиление рассуждений}
(Reasoning Enhancement), где используются такие техники, как <<цепочка мыслей>>
(Chain-of-Thought, CoT)~\cite{zhuLargeLanguageModel2024,
      huangExploringLandscapeTexttoSQL2025}.

\subsubsection{Тонкая настройка (Fine-Tuning, FT)}

В отличие от ICL, этот метод предполагает
изменение весов предобученной модели путем ее дообучения на специфичном для задачи наборе данных.
Это позволяет создавать более специализированные и точные модели, особенно когда
используются LLM с открытым исходным кодом (open-source). Выделяют два основных
подхода: \textit{полная тонкая настройка} (Full Fine-Tuning, FFT), когда обновляются
все параметры модели, и \textit{параметрически-эффективная тонкая настройка}
(Parameter-Efficient Fine-Tuning, PEFT), при которой изменяется лишь небольшая
часть весов.
Второй подход позволяет значительно сократить вычислительные ресурсы, необходимые для
дообучения~\cite{huangExploringLandscapeTexttoSQL2025}.

Отличия в методологиях ICL и FT можно визуализировать с помощью иллюстрации (см.~рис.~\ref{fig:icl-vs-ft}).

\begin{figure}[h]
      \centering
      \begin{subcaptiongroup}
            \includegraphics[width=\textwidth]{created-diagrams/icl-process.png}
            \caption{Процесс обучения в контексте (ICL)}
            \label{fig:icl-process}
            \includegraphics[width=\textwidth]{created-diagrams/ft-process.png}
            \caption{Процесс тонкой настройки (FT)}
            \label{fig:ft-process}
      \end{subcaptiongroup}
      \captionsetup{subrefformat=parens}
      \caption{Концептуальная схема, сравнивающая In-Context Learning и Fine-Tuning.}
      \label{fig:icl-vs-ft}
\end{figure}

\subsubsection{Постобработка (Post-Processing)}

Даже самые продвинутые модели могут генерировать
SQL-запросы с синтаксическими или логическими ошибками. Парадигма постобработки нацелена на
их исправление и верификацию. Один из подходов --- \textit{прямая коррекция SQL}, когда
модель сама или по заготовленным правилам ищет и исправляет ошибки в сгенерированном коде.
Более продвинутый метод --- \textit{коррекция на основе обратной связи}
(Feedback-Guided SQL Correction). В этом случае сгенерированный SQL-запрос выполняется в
базе данных, и если возникает ошибка, ее текст вместе с исходным запросом подается в модель
для повторной генерации~\cite{huangExploringLandscapeTexttoSQL2025}. Такой итеративный
подход реализован во многих современных системах, например, в компоненте Refiner системы
XiYan-SQL~\cite{gaoPreviewXiYanSQLMultiGenerator2025} или в агентных системах, таких как
MAC-SQL~\cite{zhuLargeLanguageModel2024}. Наконец, для повышения надежности используется
\textit{проверка согласованности вывода} (Output Consistency): система генерирует несколько
вариантов SQL-запроса, а затем выбирает наиболее вероятный или наиболее согласованный из них,
что является центральной идеей ансамблевого подхода в
XiYan-SQL~\cite{gaoPreviewXiYanSQLMultiGenerator2025, huangExploringLandscapeTexttoSQL2025}.

\subsubsection{Наборы данных (Datasets)}

Для обучения и объективной оценки моделей Text-to-SQL
необходимы качественные и разнообразные наборы данных.
Их развитие шло параллельно с эволюцией самих моделей,
от небольших и узкоспециализированных до масштабных и сложных.
Современные датасеты, как отмечается в~\cite{huangExploringLandscapeTexttoSQL2025},
можно разделить на несколько категорий.

Во-первых, это \textit{однодоменные} (single-domain) наборы данных,
такие как ATIS или GeoQuery, которые ориентированы на конкретную предметную
область и используются для оценки производительности моделей в узких задачах.
Во-вторых, что более актуально для
современных исследований, это \textit{междоменные} (cross-domain) датасеты.
Они требуют от моделей способности к обобщению, то есть умения работать с базами данных,
схемы которых не были представлены на этапе обучения. Ключевым датасетом в этой категории
является Spider~\cite{kimNaturalLanguageSQL2020, visperasModernTexttoSQLSemantic2023},
который стал отраслевым стандартом для оценки сложности и точности. Более поздние разработки,
такие как BIRD~\cite{huangExploringLandscapeTexttoSQL2025}, еще больше усложнили задачу,
добавив требования к обработке <<грязных>> данных и пониманию их семантики.

Помимо этого, выделяют и более специализированные
категории~\cite{huangExploringLandscapeTexttoSQL2025}:
\textit{контекстно-зависимые} (context-dependent) для оценки диалоговых систем,
\textit{ориентированные на робастность} (robustness-centered), которые проверяют
устойчивость моделей к синонимам и другим вариациям в
запросах и \textit{межъязыковые} (cross-lingual) для оценки качества работы с
неанглоязычными запросами. Именно наличие таких комплексных и
многоаспектных датасетов стимулирует исследователей к разработке все более совершенных моделей,
способных работать в условиях, приближенных к реальным~\cite{mohammadjafariNaturalLanguageSQL2025,
      gaoPreviewXiYanSQLMultiGenerator2025}.

\subsubsection{Метрики применения (Evaluation Metrics)}

Для количественной оценки
качества работы Text-to-SQL систем используются две основные группы
метрик~\cite{huangExploringLandscapeTexttoSQL2025}.

Первая группа~--- это метрики,
основанные на \textit{сопоставлении содержимого} (Content Matching-based).
Простейшей из них является \textit{точность полного совпадения строк} (Exact Matching Accuracy),
которая требует, чтобы сгенерированный SQL-запрос был посимвольно идентичен эталонному.
Это очень строгая метрика, которая не учитывает, что один и тот же результат можно
получить с помощью синтаксически разных, но семантически эквивалентных запросов.
Более гибкий подход предлагает \textit{точность совпадения компонентов} (Component-Match Accuracy),
используемая в бенчмарке Spider. Она разбивает SQL-запрос на
составные части (SELECT, WHERE, GROUP BY и т.д.) и оценивает корректность
каждой из них по-отдельности.

Вторая, и более важная с практической точки зрения, группа~--- это метрики,
основанные на \textit{результате выполнения} (Execution Result-based).
Ключевой метрикой здесь является \textit{точность выполнения} (Execution Accuracy, EX).
Она оценивает не синтаксическую схожесть запросов, а идентичность результатов,
полученных при выполнении сгенерированного и эталонного SQL-запросов на базе данных.
Именно эта метрика является основной в большинстве современных исследований и бенчмарках,
включая BIRD и Spider, так как она напрямую отражает способность системы дать
пользователю правильный ответ~\cite{huangExploringLandscapeTexttoSQL2025,
      gaoPreviewXiYanSQLMultiGenerator2025}.


\subsection{Выбор и обоснование базовой системы для реализации NLIDB}
Для практической реализации собственного естественно-языкового интерфейса в рамках
УИР необходимо выбрать конкретную систему или фреймворк,
который будет служить технологическим ядром. Выбор должен основываться на
объективных показателях производительности, архитектурном соответствии современным
тенденциям и практической применимости для решения поставленных задач.

В качестве такой системы была выбрана XiYan-SQL~--- современный ансамблевый фреймворк,
разработанный исследователями из Alibaba Group\cite{gaoPreviewXiYanSQLMultiGenerator2025}.
Данное решение представляет собой комплексный подход,
объединяющий несколько передовых методологий, рассмотренных ранее.

Выбор в пользу XiYan-SQL обусловлен несколькими причинами:

\paragraph{Лидирующие позиции в ключевых бенчмарках}. На момент проведения исследования XiYan-SQL
занимает первые места в наиболее авторитетных и сложных междоменных бенчмарках,
таких как Spider и BIRD.
Согласно данным с ресурса <<Papers with Code>>
\footnote{URL: \url{https://paperswithcode.com}}, данный фреймворк демонстрирует
лучшие результаты по метрике Execution Accuracy,
опережая другие известные системы. Графически его лидирование может быть проиллюстрировано
на графиках (см.~рис.~\ref{fig:SOTA-Spider-Bird}).
Это является объективным подтверждением
его высокой точности и способности генерировать корректные SQL-запросы
для разнообразных баз данных.

\paragraph{Современная гибридная архитектура}. С архитектурной точки зрения,
XiYan-SQL реализует передовой ансамблевый подход,
который сочетает сильные стороны как тонкой настройки,
так и обучения в контексте.
Система использует несколько генераторов~--- часть из них дообучена
для генерации высокоточных и стилистически разнообразных запросов,
а другая часть использует ICL для повышения гибкости.
Такой подход позволяет достичь баланса между точностью,
разнообразием и способностью справляться со сложными запросами.
Кроме того, в фреймворк встроены механизмы постобработки (Refiner) и
отбора лучших запросов, что полностью соответствует передовым подходам,
описанным в академической литературе~\cite{gaoPreviewXiYanSQLMultiGenerator2025,
      huangExploringLandscapeTexttoSQL2025}.

\paragraph{Практическая доступность и применимость}. Немаловажным фактором,
особенно в рамках академической работы, является практическая доступность фреймворка.
Разработчики XiYan-SQL предоставили открытый доступ к исходному коду своей системы
через репозиторий на GitHub \footnote{URL: \url{https://github.com/XGenerationLab/xiyan_mcp_server}}.
Это позволяет не просто теоретически изучить подход,
но и интегрировать его в собственный проект, адаптировать и использовать в качестве
основы для дальнейших разработок. Это значительно снижает порог вхождения и позволяет
сконцентрироваться на задачах более высокого уровня, таких как разработка
пользовательского интерфейса и логики работы веб-сервиса.

\paragraph{Соответствие задачам исследования}. На начальном этапе данная
курсовая работа предполагает создание NLIDB для работы с отдельными,
не связанными между собой таблицами. Иначе говоря, с реляционными базами данных,
состоящих из единственных таблиц. Хотя XiYan-SQL способен обрабатывать и
более сложные межтабличные запросы,
его фундаментальная точность и робастность являются отличной основой и для более
простых сценариев.

При выборе были рассмотрены и другие системы,
представленные в таблицах лидеров отраслевых бенчмарков (см.~рис.~\ref{fig:SOTA-Spider-Bird}).
Однако многие из них либо показывают более низкую производительность на
комплексных датасетах, либо представляют собой более ранние архитектурные решения,
либо не предоставляют готового к внедрению открытого кода, что делает их
использование в рамках данного проекта нецелесообразным.

Важно отметить, что данный выбор касается именно технологического ядра
для преобразования текста в SQL. Вопрос о новизне и актуальности создания
нового веб-сервиса с подобным функционалом требует отдельного анализа
существующих коммерческих и открытых продуктов, который будет проведен
на следующем этапе работы. Тем не менее, для решения центральной
задачи~--- качественной трансляции естественного языка в SQL~--- фреймворк
XiYan-SQL на сегодняшний день является наиболее мощным, современным и подходящим.




\section{Обзор существующих веб-сервисов и обоснование актуальности разработки собственного веб-сервиса}

\begin{annotation}
      В данном разделе представлен обзор существующих веб-сервисов, реализующих естественно-языковой
      интерфейс к базам данных (NLIDB), включая как проприетарные, так и решения с открытым исходным кодом.
      На основе сравнительного анализа выявляются основные
      ограничения современных решений и обосновывается актуальность
      разработки собственного веб-сервиса с NLIDB.
\end{annotation}

После выбора передового технологического ядра в лице фреймворка XiYan-SQL,
необходимо провести анализ существующих на рынке веб-сервисов, предоставляющих
функциональность естественно-языкового интерфейса к базам данных (NLIDB).
Этот анализ позволит определить, существуют ли готовые решения, полностью
удовлетворяющие потребностям целевой аудитории, и выявить незанятые ниши,
что в свою очередь обоснует актуальность и научную новизну данного проекта.
Для этого был проведен обзор нескольких популярных веб-сервисов и
open-source решений.

\subsection{Обзор существующих веб-сервисов с интеграцией ИИ для упрощения
      взаимодействия с базами данных}

\paragraph{WrenAI}. Это мощная платформа, которая существует в двух вариантах:
облачный коммерческий сервис (Wren Cloud) и решение с открытым исходным кодом
для самостоятельного развертывания (WrenAI Open Source)
\footnote{URL: \url{https://docs.getwren.ai/oss/overview/introduction}}.
Система позволяет создавать как собственные базы данных (CSV), так и напрямую подключаться к
широкому спектру реляционных баз данных. Ключевым недостатком для нетехнического
пользователя является необходимость локальной установки и настройки open-source версии,
что требует определенных технических навыков. Кроме того, система в своей основе полагается
на API от OpenAI, что создает барьер для пользователей из России и повышает зависимость
от стороннего платного сервиса. Пользовательский интерфейс, хоть и функциональный, может
показаться перегруженным для базовых задач.

\paragraph{SQLAI}. Данный сервис позиционируется как многофункциональный инструмент,
ориентированный не только на конечных пользователей, но и на разработчиков
\footnote{URL: \url{https://www.sqlai.ai/documentation/introduction/introduction}}.
Он предлагает генерацию SQL-запросов, их оптимизацию и отладку. Важным преимуществом
является поддержка не только реляционных, но и некоторых NoSQL баз данных. Однако, это
полностью коммерческий продукт с закрытым исходным кодом, что делает невозможным его
кастомизацию и изучение внутреннего устройства. Англоязычный интерфейс и широкий, но
избыточный для нетехнического специалиста функционал, делают его менее подходящим для
целей нашего исследования.

\paragraph{ai2sql}. Этот сервис сфокусирован на простоте и предлагает интуитивно
понятный интерфейс для преобразования запросов на естественном языке в SQL
\footnote{URL: \url{https://ai2sql.io}}. Он поддерживает работу с загружаемыми CSV-файлами,
что является удобным сценарием для пользователей, не имеющих прямого доступа к базам данных.
Как и предыдущий аналог, ai2sql является проприетарным решением с закрытым исходным кодом и
англоязычным интерфейсом, что ограничивает его применимость и прозрачность.

\paragraph{SQLchat}. SQLchat~--- это проект с открытым исходным кодом,
который предоставляет веб-интерфейс для <<общения>> с базой данных
\footnote{URL: \url{https://www.sqlchat.ai}}. Его основное преимущество~--- открытость и простота.
Однако, он не поддерживает загрузку данных из файлов (например, CSV) и требует от пользователя
прямого подключения к уже существующей и настроенной базе данных, что может быть барьером для
целевой аудитории.

\paragraph{AI SQL Gen}. Данный проект является типичным примером простой системы-обертки над
GPT-4 \footnote{URL: \url{https://github.com/marblexyz/aisqlgen}}, что наглядно демонстрирует его
архитектура (см.~рис.~\ref{fig:aisqlgen_arch}). Он требует от пользователя
наличия собственного ключа OpenAI API, запускается локально и не обновлялся в течение долгого
времени. Несмотря на простоту, такие системы полностью зависят от стороннего сервиса и не
предлагают никакой дополнительной ценности в виде продвинутого связывания со схемой или
поддержки различных моделей.

\begin{figure}[ht]
      \begin{center}
            \includegraphics[width=0.9\textwidth]{literature-review/aisqlgen-diagram.png}
      \end{center}
      \caption{Архитектура типичной системы-обертки (на примере AI SQL Gen)}
      \label{fig:aisqlgen_arch}
\end{figure}

\subsection{Сравнительный анализ и обоснование актуальности собственной разработки}

Проведенный обзор позволяет систематизировать существующие решения и выявить их
ключевые характеристики, которые представлены в виде сравнительной таблицы
(см.~табл.~\ref{table:services_comparison}).

\begin{table}[ht]
      \caption{Сравнительная таблица существующих NLIDB-сервисов}\label{table:services_comparison}
      \begin{tabularx}{\linewidth}{|>{\bfseries}l|X|X|X|}
            \hline
            \textbf{Сервис} & \textbf{Модель развертывания}                              & \textbf{Подключение данных}                & \textbf{Модель монетизации и API}                             \\
            \hline
            WrenAI          & Open-source (локальный) или проприетарный веб-сервис Cloud & CSV, прямое подключение к БД               & Требует ключ OpenAI API при использовании open-source решения \\
            \hline
            SQLAI.ai        & Проприетарный веб-сервис                                   & Прямое подключение к БД (SQL     \& NoSQL) & Коммерческий, закрытый исходный код                           \\
            \hline
            ai2sql.io       & Проприетарный веб-сервис                                   & Загрузка CSV, прямое подключение           & Коммерческий, закрытый исходный код                           \\
            \hline
            SQLchat         & Open-source (локальный)                                    & Только прямое подключение к БД             & Бесплатный, с открытым кодом, требует ключ OpenAI API         \\
            \hline
            AI SQL Gen      & Open-source (локальный)                                    & Только прямое подключение к БД             & Требует ключ OpenAI API                                       \\
            \hline
      \end{tabularx}
\end{table}

Анализ таблицы и детальный обзор сервисов позволяет сделать несколько ключевых выводов
и выявить недостатки у альтернативых решений, что и обосновывает актуальность в собственной разработке
веб-сервиса в рамках УИР.

\begin{compactitem}
      \item \textbf{Проблема доступности}. На рынке наблюдается четкое разделение:
      либо платные, закрытые веб-сервисы, либо open-source проекты,
      требующие от пользователя технических навыков для локального развертывания.
      Практически отсутствует ниша веб-сервиса, который был бы одновременно
      с открытым исходным кодом, бесплатным для конечного пользователя и доступным онлайн
      без необходимости установки.
      \item \textbf{Зависимость от проприетарных API}. Большинство доступных решений,
      включая open-source, жестко привязаны к API коммерческих LLM, в первую очередь~--- OpenAI.
      Это создает существенный барьер для пользователей из России
      (из-за сложностей с оплатой и регистрацией) и повышает риски,
      связанные с конфиденциальностью данных, передаваемых на сторонние серверы.
      \item \textbf{Непрозрачность технологического ядра}. Коммерческие сервисы не раскрывают,
      какие модели и методы они используют <<под капотом>>. В то же время,
      многие простые open-source проекты используют базовые подходы без применения передовых техник.
      Создание сервиса на основе доказуемо лидирующего фреймворка, такого как XiYan-SQL,
      является важным преимуществом с точки зрения научной и инженерной проработки.
\end{compactitem}

Таким образом, выявлена четкая потребность в создании веб-сервиса с открытым исходным кодом,
который не требует от конечного пользователя сторонних API-ключей,
прост в использовании и основан на современной, высокопроизводительной модели для
генерации SQL-запросов. Разработка такого продукта не только представляет
академический интерес как пример интеграции лидирующей модели в прикладной инструмент,
но и обладает высокой практической ценностью, предлагая рынку уникальное и востребованное решение.
Это и определяет актуальность и новизну дальнейшей работы.




\section{Выводы}

В рамках данного исследования был проведен комплексный анализ проблематики
взаимодействия нетехнических пользователей с базами данных,
а также обзор и сравнение существующих подходов и технологий для решения этой проблемы.
Основной целью анализа было создание концепта итогового продукта при
разработке собственного естественно-языкового интерфейса, а также проверка его актуальности и
новизны подходов.
По результатам проделанной работы
были сделаны следующие ключевые выводы, которые определяют дальнейший ход проекта:

\begin{compactenum}
      \item Выявлена проблема возникновения трудностей у нетехнических пользователей
      при взаимодействии с базами данных. Анализ традиционных
      способов взаимодействия с базами данных однозначно
      показал, что все они требуют от пользователя наличия специальных технических знаний,
      что и является основным препятствием для нетехнических специалистов.
      \item Проделан сравнительный анализ адаптированных пользовательских
      интерфейсов. На основании преимуществ и недостатков таких интерфейсов, как QBE, VQS или
      NLIDB~--- был сделан вывод,
      что именно естественно-языковые интерфейсы (NLIDB) являются наиболее перспективным направлением,
      так как они предлагают самый высокий уровень абстракции и интуитивности,
      полностью скрывая от пользователя сложность структуры данных и синтаксиса формальных языков,
      что дало повод сконцентрироваться на исследовании именно такого вида взаимодействия с БД.
      \item Определена доминирующая технология. Глубокий анализ систем,
      решающих задачу преобразования естественного языка в SQL (Text-to-SQL),
      показал четкую эволюцию от ранних систем на правилах к современным решениям на
      основе больших языковых моделей (LLM). Было установлено, что лучшую
      производительность сегодня демонстрируют гибридные LLM-основанные фреймворки,
      которые комбинируют различные методологии
      для достижения максимальной точности и робастности при решении исходной задачи.
      \item Выбрано конкретное технологическое ядро. На основе анализа производительности,
      архитектурных особенностей и практической доступности был выбран фреймворк XiYan-SQL
      в качестве базовой системы для реализации собственного NLIDB. Этот выбор обоснован его лидирующими
      позициями в ключевых отраслевых бенчмарках, современной ансамблевой архитектурой,
      а также наличием открытого исходного кода, что позволяет интегрировать его в собственный проект.
      \item Обоснована актуальность и новизна разработки.
      Было установлено, что на данный момент практически отсутствуют веб-сервисы, которые
      бы одновременно являлись:
      \begin{compactitem}
            \item Полностью бесплатными и доступными онлайн без локальной установки.
            \item Основанными на открытом исходном коде.
            \item Не требующими от конечного пользователя предоставления собственных API-ключей
            к платным проприетарным LLM.
      \end{compactitem}
\end{compactenum}

Таким образом, результаты анализа, проведенного в данной части УИР, подтвердили актуальность
поставленной задачи и позволили сформировать план
для ее решения. Дальнейшая работа будет сконцентрирована на проектировании, разработке и
тестировании собственного веб-сервиса, который будет использовать фреймворк XiYan-SQL в качестве
ядра для трансляции запросов, предоставляя доступный, бесплатный и прозрачный инструмент для
широкого круга нетехнических пользователей.




\section{Цели и задачи на УИР}

Целью данного УИР является проектирование модели интеграции современного многомодульного
NLIDB-ядра XiYan-SQL во внешний веб-сервис. Эта интеграция достигается через разработку
архитектуры компонента-оркестратора, а именно \textbf{MCP-клиента}, который инкапсулирует
всю сложность взаимодействия с ядром.

Практической апробацией предложенной модели служит разработка и
тестирование программного прототипа веб-сервиса. На данном этапе исследования
прототип \textbf{эмулирует} взаимодействие с ядром XiYan-SQL, что позволяет проверить
корректность и жизнеспособность спроектированной архитектуры в контролируемой среде.

Для достижения поставленной цели необходимо решить следующие задачи:
\begin{compactenum}
      \item Проанализировать архитектуру и протокол взаимодействия многоагентного сервера
      XiYan-SQL MCP Server для определения требований к клиентской части.
      \item Спроектировать логику работы (модель взаимодействия) MCP-клиента,
      определяющую полный жизненный цикл обработки пользовательского запроса.
      Это включает последовательность вызовов к различным AI-агентам ядра: агенту связывания со
      схемой, генераторам кандидатов и агенту выбора конечного результата.
      \item Определить внутренний API компонента MCP-клиента для его взаимодействия с
      остальными частями серверной логики веб-приложения.
      \item Спроектировать общую клиент-серверную архитектуру веб-сервиса,
      который предоставляет пользователю интерфейс для выполнения запросов к
      базам данных на естественном языке.
      \item Разработать программный прототип веб-сервиса, реализующий спроектированную архитектуру.
      Прототип должен включать серверную часть (Backend), пользовательский интерфейс (Frontend) и,
      самое главное, модуль MCP-клиента с \textbf{эмуляцией} вызовов к ядру XiYan-SQL.
      \item Провести функциональное тестирование разработанного прототипа для проверки
      корректности работы реализованной модели взаимодействия MCP-клиента и
      пользовательского интерфейса.
\end{compactenum}